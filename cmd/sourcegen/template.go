package main // import "golang.handcraftedbits.com/ezif/cmd/sourcegen"

//
// Private variables
//

var templateAccessorSource = `// Code generated by ezif.  DO NOT EDIT.

package {{ .PackageName | LastPackage }} // import "golang.handcraftedbits.com/ezif/{{ .PackageName }}"

import (
	"math/big"
	"time"

	"golang.handcraftedbits.com/ezif"
)

//
// Public types
//

// Accessor is the interface used to access interpreted image metadata property values.
type Accessor interface {
	// Interpreted accesses the interpreted value of an image metadata property.
	Interpreted () string
}

{{ range .AccessorInterfaces }}
// {{ .Name }} is the interface used to access image metadata properties with {{ .Type }} values.
type {{ .Name }}Accessor interface {
	Accessor

	// Raw accesses the raw {{ .Type }} value of an image metadata property.
	Raw () {{ .Type }}
}
{{ end }}

//
// Public functions
//

{{ range .AccessorImplementations }}
	{{ $methodName := printf "New%s" .Family }}
	{{ if not (eq .ValueMethodAlias "") }}
		{{ $methodName = printf "%s%s" $methodName .ValueMethodAlias }}
	{{ else }}
		{{ $methodName = printf "%s%s" $methodName .ValueMethod }}
	{{ end }}
	// {{ $methodName }}{{ if .IsSlice }}Slice{{ end }}Accessor creates an accessor for image metadata properties ` +
	`with {{ .Type }} values.
	func {{ $methodName }}{{ if .IsSlice}}Slice{{ end }}Accessor (metadata ezif.{{ .Family }}Metadata, key string) ` +
	`{{ .InterfaceName }}Accessor {
		if !metadata.HasKey(key) {
			return nil
		}

		return &{{ .Name }}Accessor{
			datum: metadata.Get(key),
		}
	}
{{ end }}

//
// Private types
//

{{ range .AccessorImplementations }}
	// {{ .InterfaceName }}Accessor implementation for {{ .Family }} metadata
	type {{ .Name }}Accessor struct {
		datum ezif.{{ .Family }}Datum
	}

	func (accessor *{{ .Name }}Accessor) Raw () {{ .Type }} {
		{{- if .IsSlice }}
			var result = make({{ .Type }}, len(accessor.datum.Values()))

			for i, value := range accessor.datum.Values() {
				result[i] = value.{{ .ValueMethod }}()
			}

			return result
		{{ else }}
			return accessor.datum.{{ if eq .Family "XMP" }}Value(){{ else }}Values()[0]{{ end }}.{{ .ValueMethod }}()
		{{ end -}}
	}

	func (accessor *{{ .Name }}Accessor) Interpreted () string {
		return accessor.datum.InterpretedValue()
	}
{{ end }}
`

var templateGroupSource = `// Code generated by ezif.  DO NOT EDIT.

/* Package {{ .PackageName | LastPackage }} defines helper functions for accessing {{ .PackageDescription }}.
 *
 * See the Exiv2 documentation for more information: {{ .Reference }}
 */
package {{ .PackageName | LastPackage }} // import "golang.handcraftedbits.com/ezif/helper/{{ .PackageName }}"

import (
{{- range RequiredImports .FunctionMappings false }}
	"{{ . }}"
{{ end -}}
)

{{- $disabledHelpers := .DisabledHelpers }}
{{- $familyName := .FamilyName -}}
{{- $functionMappings := .FunctionMappings }}

//
// Public functions
//

{{ range .FunctionNames }}
	{{- $functionInfo := index $functionMappings . }}
	
	{{- if IsHelperEnabled $functionInfo $disabledHelpers }}
		// {{ . }} is used to get or set the "{{ $functionInfo.Tag.Label }}" {{ $familyName }} metadata, which is ` +
	`described as "{{ $functionInfo.Tag.Description | FixDescription }}."  See the Exiv2 documentation regarding ` +
	`key "{{ $functionInfo.FullTagName }}" for more information.  Note that this function will return nil if the ` +
	`image metadata does not contain this property.
		func {{ . }} (metadata ezif.ImageMetadata) {{ ReturnType $familyName $functionInfo }} {
			return {{ ValueFunction $familyName $functionInfo }}(metadata.{{ $familyName }}(), ` +
	`"{{ $functionInfo.FullTagName }}")
		}
	{{ end -}}
{{ end -}}
`

var templateGroupTestSource = `// Code generated by ezif.  DO NOT EDIT.

package {{ .PackageName | LastPackage }} // import "golang.handcraftedbits.com/ezif/helper/{{ .PackageName }}"

import (
{{- range RequiredImports .FunctionMappings true }}
	"{{ . }}"
{{ end -}}
)

{{- $disabledHelpers := .DisabledHelpers }}
{{- $disabledTests := .DisabledTests }}
{{- $familyName := .FamilyName -}}
{{- $functionMappings := .FunctionMappings }}

//
// Public functions
//

{{ range .FunctionNames }}
	{{- $functionInfo := index $functionMappings . }}
	
	{{- if and (IsHelperEnabled $functionInfo $disabledHelpers) (IsTestEnabled $functionInfo $disabledTests) }}
		func Test{{ . }} (t *testing.T) {
			var accessorFunc = func(metadata ezif.ImageMetadata) helper.Accessor {
				return {{ . }}(metadata)
			}

			var getFunc = func(metadata ezif.ImageMetadata) interface{} {
				return {{ . }}(metadata).Raw()
			}

			t.Run(internal.SubTestMaxValue, func(t *testing.T) {
				_ = internal.TestGetValueFromHelper(t, "{{ $functionInfo.FullTagName }}", getFunc,
					{{ MaxValue $familyName $functionInfo }})
			})

			t.Run(internal.SubTestMissingValue, func(t *testing.T) {
				internal.TestGetMissingValueFromHelper(t, "{{ $functionInfo.FullTagName }}", accessorFunc)
			})
		}
	{{ end -}}
{{ end -}}
`
